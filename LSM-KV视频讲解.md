# LSM-KV视频讲解

### 0 项目结构

在开始介绍三个部分之前，我们先来介绍一下项目的整体结构。

本项目采用面对对象的原则，将LSM-KV的内存外存部分都封装成了独立的类，称为MemTable和SSTable。

MemTable的核心数据结构是跳表。

SSTable的核心数据结构 是外存缓存列表levels。levels是一个std::vector<std::list < Buffer > >，他的元素个数与外存中sstable的层级数一致，而其中的每一个std::list元素则对应着一层中的各个文件，而Buffer是对单个sstable的缓存数据结构。

在compaction函数之外的任何时刻，sstable中的头部数据和levels中的数据保持同步。



### 1 scan实现方法

分为两部分。

首先，调用MemTable中的scan成员函数，将内存中存在的符合条件的数据，放到传入的list引用变量中。

然后，再调用SSTable中的scan成员函数。该函数搜索levels的每一层中的每一个Buffer，如果通过最大索引值和最小索引值所包含的范围和scan的范围有重叠，则要访问文件获取其中的所有数据，然后再从前到后遍历。这个函数中最核心的数据结构是一个

std::list< std::< pair< std::pair < uint64_t, uint64_t >, string > > >。

其中，三个数据类型表示的分别是键值对的索引值，键值对的时间戳，以及字符串数据。之所以设计成这样，是因为要利用std::list中的方法sort()。std::pair的排序原则是，先比较第一个元素，按非降序排列，若相等，则比较第二个元素，也按非降序排列。于是将上述数据结构排列完了之后，就可以实现索引值小的数据在前，或者相同索引值中，时间戳小的数据在前。方便后续按照时间戳的去重操作。

### 2 compaction实现方法

在提供的四个api中，只有put会显式地插入数据到LSM-KV结构（del会调用put）。于是，只有put会进行是否需要进行compaction的逻辑判断。put首先会调用MemTable的insert。如果超过了内存限制，则该函数返回true，通知put可以调用外存中的compaction了。

compaction从levels的最小元素开始，若该层的缓存数量已经超过了上限，则触发compaction。

具体做法为，如果下一层不存在，则创建下一层。然后搜索下一层中与当前需要合并的文件索引值有交集的所有文件，组成一个需要合并的Buffer。通过文件流，写入下一层的文件夹中。

### 3 跳表介绍

本实验的内存部分采用的是跳表数据结构。

首先定义一个枚举类，表示跳表节点类型。

定义节点的结构体，包含索引值，数据，节点类型等。

然后定义跳表数据结构。

主要的函数是insert，search。

其中search即从头结点开始，从最顶层开始搜索，以较大的步长跨越跳表，当且仅当下一个索引值不小于要查询的索引值，并且下一层非空时，进入下一层。在平均上能达到对数级别的时间复杂度。

insert则需要创建新的节点，然后更新所有层级的链接关系。新节点的层级数是随机数产生的，在新节点所涉及的层级，其插入位置之前的所有节点，需要在该层级指向新节点，而同时新节点在该层级需要指向原来之前节点的下一个节点。